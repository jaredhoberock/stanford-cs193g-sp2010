#summary Hello, world! in CUDA.
#labels Phase-Deploy

= Hello, world! =

In the previous section, we saw that CUDA presents a view of memory that is partitioned into separate _host_ and _device_ memory spaces.  Similarly, CUDA requires the programmer to segregate code into functions which execute on either the host or device (or both).  The first kind of these functions is called a `__global__` function.  `__global__` functions, or _kernels_, are like the `main` function from C.  They are the first point of entry into a program which is executed by the GPU device.

One important way in which `__global__` functions differ from normal C functions is that they are executed _in parallel_.  When we make a function call in C, a single thread of control enters that function, does some work, and then returns control to the calling function. Instead, `__global__` functions execute in parallel over hundreds, thousands, or even _hundreds of thousands_ of CUDA threads.

To see CUDA threads in action, let's compile the following Hello, world! program.

{{{
#include "util/cuPrintf.cu"
#include <stdio.h>

__global__ void device_greetings(void)
{
  cuPrintf("Hello, world from the device!\n");
}

int main(void)
{
  // greet from the host
  printf("Hello, world from the host!\n");

  // initialize cuPrintf
  cudaPrintfInit();

  // launch a kernel with a single thread to greet from the device
  device_greetings<<<1,1>>>();

  // display the device's greeting
  cudaPrintfDisplay();
  
  // clean up after cuPrintf
  cudaPrintfEnd();

  return 0;
}
}}}

This program requires the non-standard file `cuPrintf.cu`, which is [http://code.google.com/p/stanford-cs193g-sp2010/source/browse/trunk/tutorials/util/cuPrintf.cu available] in this site's code repository.

Let's compile this program by copying it to a file called `hello_world.cu`.  Place the file `cuPrintf.cu` in a directory called `util` at the same level as `hello_world.cu`.  We don't need to specify a special include directory to `nvcc` since it searches the current directory by default.

Compiling and running the program on a Mac OSX system yields

{{{
$ nvcc hello_world.cu -o hello_world
$ ./hello_world 
Hello, world from the host!
Hello, world from the device!
}}}

It works, but a single greeting doesn't seem very parallel.  You'll notice from the comment in the above program that we _launched_ a single CUDA thread using some strange looking function call syntax.  The triple chevron `<<<B,N>>>` notation _configures_ a kernel's launch by specifying the number `B` of thread groups, or _blocks_, and the number `N` of threads per block.  Let's see what happens when change the kernel launch's configuration.

Try changing the line

{{{
  device_greetings<<<1,1>>>();
}}}

to

{{{
  device_greetings<<<10,64>>>();
}}}

and recompiling.  You'll be greeted by `10 * 64 = 640` threads!

{{{
yucky:tutorials jared$ ./hello_world 
Hello, world from the host!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
Hello, world from the device!
...
}}}

As always, you can view the full source code of this example along with additional commentary in our [http://code.google.com/p/stanford-cs193g-sp2010/source/browse/trunk/tutorials/hello_world.cu code repository].  We'll see what else `__global__` functions can do in the [TutorialGlobalFunctions next section].